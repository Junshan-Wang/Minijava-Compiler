//
//Generated by JTB 1.3.2
//

package spiglet.visitor;

import java.util.*;

import spiglet.visitor.*;
import spiglet.spiglet2kanga.Interval;
import spiglet.spiglet2kanga.MyProcedure;
import spiglet.syntaxtree.*;

/**
* Provides default methods which visit each node in the tree in depth-first
* order.  Your visitors may extend this class.
*/
public class Spiglet2kangaVisitor extends GJNoArguDepthFirst<String> {
//
// Auto class visitors--probably don't need to be overridden.
//
private HashMap<String, MyProcedure> procedures;			//所有过程
private MyProcedure currentProc;							//当前过程
private Boolean v;										//变量赋值或被赋值
private String storeBack;								//保存被赋值变量需要写回栈中的语句
private int line;										//当前行数，用于判断变量是否活跃

public String output;

public Spiglet2kangaVisitor(HashMap<String, MyProcedure> procedures_) {
	this.procedures=procedures_;
	this.v=false;
	this.output="";
}

public void printx(String str){
	//for (int i=0;i<indentation;++i){
	//	str="  "+str;
	//}		
	//System.out.println(str);
	output+=str+"\n";
}


public String visit(NodeList n) {
   for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
      e.nextElement().accept(this);
   return null;
}

public String visit(NodeListOptional n) {
   if ( n.present() )
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
         e.nextElement().accept(this);
   return null;
}

public String visit(NodeOptional n) {
   if ( n.present() )
	   //System.out.print(n.node.accept(this)+" ");
	   output+=n.node.accept(this)+" ";
   return null;
}

public String visit(NodeSequence n) {
   for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); )
      e.nextElement().accept(this);
   return null;
}

public String visit(NodeToken n) { 
	return null;
}

//
// User-generated visitor methods below
//

/**
 * f0 -> "MAIN"
 * f1 -> StmtList()
 * f2 -> "END"
 * f3 -> ( Procedure() )*
 * f4 -> <EOF>
 */
public String visit(Goal n) {
	line=0;
	currentProc=procedures.get("MAIN");
	printx("MAIN [0]["+currentProc.stackSize+"]["+currentProc.maxPars+"]");
	line++;
	n.f1.accept(this);
	printx("END");
	
   n.f3.accept(this);
   return null;
}

/**
 * f0 -> ( ( Label() )? Stmt() )*
 */
public String visit(StmtList n) {
   n.f0.accept(this);
   return null;
}

/**
 * f0 -> Label()
 * f1 -> "["
 * f2 -> IntegerLiteral()
 * f3 -> "]"
 * f4 -> StmtExp()
 */
public String visit(Procedure n) {
	line=0;
	currentProc=procedures.get(n.f0.f0.toString());
	printx("");
	printx(currentProc.name+" ["+n.f2.f0.toString()+"]["+currentProc.stackSize+"]["+currentProc.maxPars+"] ");
	
	int pars=Integer.parseInt(n.f2.f0.toString());
	
	//保存局部变量，即过程中使用的s寄存器!!!注意栈的位置
	int t=0;
	for (int i=0;i<currentProc.variables.size();++i) {
		String t1=currentProc.register[currentProc.variables.get(i).tempID];
		if (t1!=null) { 
			printx("ASTORE SPILLEDARG "+((t++)+currentProc.spillSize)+" "+t1);
		}
	}
		
	//获得参数，参数对应寄存器或栈，参数保存在a寄存器或栈
	for (int i=0;i<pars;++i) {
		String t1=currentProc.register[i];
		String t2=currentProc.location[i];
		if (t1!=null) {
			if (i<4) printx("MOVE "+t1+" a"+i);
			else {
				printx("ALOAD v0 SPILLEDARG "+(i-4));
				printx("MOVE "+t1+" v0");
			}
		}
		else if (t2!=null) {
			if (i<4) printx("MOVE v0"+" a"+i);
			else printx("ALOAD v0 SPILLEDARG "+(i-4));
			printx("ASTORE SPILLEDARG "+t2+" v0");
		}
	}
	
	line++;
	n.f4.accept(this);
	
	//恢复局部变量，即s寄存器
	t=0;
	for (int i=0;i<currentProc.variables.size() ;++i) {
		String t1=currentProc.register[currentProc.variables.get(i).tempID];
		if (t1!=null) 
		{ 
			printx("ALOAD "+t1+" SPILLEDARG "+((t++)+currentProc.spillSize));
		}
	}
	
	printx("END");
	return null;
}

/**
 * f0 -> NoOpStmt()
 *       | ErrorStmt()
 *       | CJumpStmt()
 *       | JumpStmt()
 *       | HStoreStmt()
 *       | HLoadStmt()
 *       | MoveStmt()
 *       | PrintStmt()
 */
public String visit(Stmt n) {
   n.f0.accept(this);
   return null;
}

/**
 * f0 -> "NOOP"
 */
public String visit(NoOpStmt n) {
	line++;
	printx("NOOP");
	return null;
}

/**
 * f0 -> "ERROR"
 */
public String visit(ErrorStmt n) {
	line++;
	printx("ERROR");
	return null;
}

/**
 * f0 -> "CJUMP"
 * f1 -> Temp()
 * f2 -> Label()
 */
public String visit(CJumpStmt n) {
   String t1=n.f1.accept(this);
   printx("CJUMP "+t1+" "+n.f2.f0.toString());
   line++;
   return null;
}

/**
 * f0 -> "JUMP"
 * f1 -> Label()
 */
public String visit(JumpStmt n) {
   printx("JUMP "+n.f1.f0.toString());
   line++;
   return null;
}

/**
 * f0 -> "HSTORE"
 * f1 -> Temp()
 * f2 -> IntegerLiteral()
 * f3 -> Temp()
 */
public String visit(HStoreStmt n) {
   String t1=n.f1.accept(this);  
   String num=n.f2.accept(this);   
   v=true;String t2=n.f3.accept(this);v=false;
   
   printx("HSTORE "+t1+" "+num+" "+t2);
   
   line++;
   return null;
}

/**
 * f0 -> "HLOAD"
 * f1 -> Temp()
 * f2 -> Temp()
 * f3 -> IntegerLiteral()
 */
public String visit(HLoadStmt n) {
	String t1=n.f1.accept(this);	
	v=true;String t2=n.f2.accept(this);v=false;   
	String num=n.f3.accept(this);
	
	if (t1!=null){
		printx("HLOAD "+t1+" "+t2+" "+num);
		if (t1=="v0") printx(storeBack);
	}
	
	line++;
	return null;
}

/**
 * f0 -> "MOVE"
 * f1 -> Temp()
 * f2 -> Exp()
 */
public String visit(MoveStmt n) {
	String t1=n.f1.accept(this);
   	if (t1=="v0") v=true;
   		String exp=n.f2.accept(this);
   	if (t1=="v0") v=false;
   //System.out.println("1");
   if (t1!=null) {
	   printx("MOVE "+t1+" "+exp);
	   if (t1=="v0") printx(storeBack);
   }
   line++;
   return null;
}

/**
 * f0 -> "PRINT"
 * f1 -> SimpleExp()
 */
public String visit(PrintStmt n) {
   String exp=n.f1.accept(this);
   printx("PRINT "+exp);
   line++;
   return null;
}

/**
 * f0 -> Call()
 *       | HAllocate()
 *       | BinOp()
 *       | SimpleExp()
 */
public String visit(Exp n) {
   return n.f0.accept(this);
}

/**
 * f0 -> "BEGIN"
 * f1 -> StmtList()
 * f2 -> "RETURN"
 * f3 -> SimpleExp()
 * f4 -> "END"
 */
public String visit(StmtExp n) {
   //printx("BEGIN");
	line++;
	n.f1.accept(this);
   //printx("RETURN");
	printx("MOVE v0 "+n.f3.accept(this));
	line++;
   //printx("END");
	line++;
	return "v0";
}

/**
 * f0 -> "CALL"
 * f1 -> SimpleExp()
 * f2 -> "("
 * f3 -> ( Temp() )*
 * f4 -> ")"
 */
public String visit(Call n) {
	Vector<Node> pars = n.f3.nodes;
	//过程调用，若参数少于4个，则a传递，否则压栈
	for (int i=0;i<n.f3.size();++i) {
		String t1=pars.get(i).accept(this);
		if (i<4) printx("MOVE a"+i+" "+t1);
		else printx("PASSARG "+(i-3)+" "+t1);
	}
	printx("CALL "+n.f1.accept(this));
	return "v0";
}

/**
 * f0 -> "HALLOCATE"
 * f1 -> SimpleExp()
 */
public String visit(HAllocate n) {
   return "HALLOCATE "+n.f1.accept(this);
}

/**
 * f0 -> Operator()
 * f1 -> Temp()
 * f2 -> SimpleExp()
 */
public String visit(BinOp n) {
	if (v==true) { 
		printx("MOVE a1 v0"); 
		v=false;
		String op=n.f0.accept(this);
		v=true; String t1=n.f1.accept(this); v=false;
		String exp=n.f2.accept(this);
		printx("MOVE v1 "+op+" "+t1+" "+exp);
		printx("MOVE v0 a1");
		return "v1";
	}
	else {
		String op=n.f0.accept(this);
		v=true; String t1=n.f1.accept(this); v=false;
		String exp=n.f2.accept(this);
		return op+" "+t1+" "+exp;
	}
	//return op+" "+t1+" "+exp;
}

/**
 * f0 -> "LT"
 *       | "PLUS"
 *       | "MINUS"
 *       | "TIMES"
 */
public String visit(Operator n) {
	String[] ops = { "LT", "PLUS", "MINUS", "TIMES" };
	return ops[n.f0.which];
}

/**
 * f0 -> Temp()
 *       | IntegerLiteral()
 *       | Label()
 */
public String visit(SimpleExp n) {
	return n.f0.accept(this);
}

/**
 * f0 -> "TEMP"
 * f1 -> IntegerLiteral()
 */
public String visit(Temp n) {
	String regName;
	int i=Integer.parseInt(n.f1.accept(this));

	//如果当前变量是活跃的，则返回其寄存器或在栈中的位置，如果变量被赋值且在栈中，则要写回
	if (currentProc.live.get(line).get(i)) {
		if ((regName=currentProc.register[i])!=null) {
			return regName;
		}
		else if (currentProc.location[i]!=null){
			if (v==false) {
				regName="v0";
				storeBack="ASTORE SPILLEDARG "+currentProc.location[i]+" "+regName;
			}
			else regName="v1";
			printx("ALOAD "+regName+" SPILLEDARG "+currentProc.location[i]);
			return regName;
		}
		else {
			return null;
		}
	}
	else return null;
}

/**
 * f0 -> <INTEGER_LITERAL>
 */
public String visit(IntegerLiteral n) {
	return n.f0.toString();
}

/**
 * f0 -> <IDENTIFIER>
 */
public String visit(Label n) {
	return n.f0.toString();
}
}