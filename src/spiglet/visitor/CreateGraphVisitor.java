//
//Generated by JTB 1.3.2
//
package spiglet.visitor;

import java.util.*;
import spiglet.visitor.*;
import spiglet.spiglet2kanga.MyBlock;
import spiglet.spiglet2kanga.MyProcedure;
import spiglet.spiglet2kanga.MyStatement;
import spiglet.syntaxtree.*;

/**
* Provides default methods which visit each node in the tree in depth-first
* order.  Your visitors may extend this class.
*/
public class CreateGraphVisitor extends DepthFirstVisitor {

public HashMap<String, MyProcedure> procedures;		//所有过程
public MyProcedure currentProc;						//当前过程
public MyBlock currentBlock;						//当前基本块
public MyStatement currentStat;						//当前语句

public int line;									//在过程中的行数

public int identifier;								//保存label返回的标识符
public Boolean isVars;								//是否是过程调用的参数
public Boolean isLabel;								//是否是Label
public Boolean isReturn;							//是否是返回值

public HashMap<MyBlock, Integer> nextLabelList;		//保存Label，用于写回跳转语句中顺序执行的行数及其基本块
public HashMap<MyBlock, String> jumpLabelList;		//保存Label，用于写回跳转语句中跳转执行的Label号及其基本块

public MyStatement lastStat;
public int lastIdentifier;

public CreateGraphVisitor() {
	isVars=false;
	isLabel=false;
	isReturn=false;
	procedures=new HashMap<String, MyProcedure>();
	nextLabelList=new HashMap<MyBlock, Integer>();
	jumpLabelList=new HashMap<MyBlock, String>();
}

public void visit(NodeList n) {
   int _count=0;
   for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
      e.nextElement().accept(this);
      _count++;
   }
}

public void visit(NodeListOptional n) {
   if ( n.present() ) {
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
   }
}

public void visit(NodeOptional n) {
   if ( n.present() )
      n.node.accept(this);
}

public void visit(NodeSequence n) {
   int _count=0;
   for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
      e.nextElement().accept(this);
      _count++;
   }
}

public void visit(NodeToken n) {}

//
// User-generated visitor methods below
//

/**
 * f0 -> "MAIN"
 * f1 -> StmtList()
 * f2 -> "END"
 * f3 -> ( Procedure() )*
 * f4 -> <EOF>
 */
public void visit(Goal n) {
	line=0;
	nextLabelList.clear();
	jumpLabelList.clear();
	currentProc=new MyProcedure("MAIN");
	procedures.put(currentProc.name, currentProc);
	
	currentBlock=new MyBlock(line);
	currentProc.addBlck(currentBlock);
	
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	line++;	
	n.f1.accept(this);
	
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	currentBlock.exit(line-1);
	
	//主程序中写回跳转语句的目标基本块，活性分析，寄存器分配
	currentProc.writeBack(nextLabelList, jumpLabelList);
	currentProc.livenessAnalyse();
	currentProc.LSRegisterAllocation();
	
	n.f3.accept(this);
	
}

/**
 * f0 -> ( ( Label() )? Stmt() )*
 */
public void visit(StmtList n) {
   n.f0.accept(this);
}

/**
 * f0 -> Label()
 * f1 -> "["
 * f2 -> IntegerLiteral()
 * f3 -> "]"
 * f4 -> StmtExp()
 */
public void visit(Procedure n) {	
	line=0;
	nextLabelList.clear();
	jumpLabelList.clear();
	currentProc=new MyProcedure(n.f0.f0.toString());
	procedures.put(currentProc.name, currentProc);
	
	//参数大于4，保存在栈中
	if (Integer.parseInt(n.f2.f0.toString())>4) 
		currentProc.stackSize+=(Integer.parseInt(n.f2.f0.toString())-4);
	
	currentBlock=new MyBlock(line);
	currentProc.addBlck(currentBlock);
	
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	n.f2.accept(this);
	
	line++;		
	n.f4.accept(this);
	currentBlock.exit(line-1);
	
	//子程序中写回跳转语句的目标基本块，活性分析，寄存器分配
	currentProc.writeBack(nextLabelList, jumpLabelList);
	currentProc.livenessAnalyse();
	currentProc.LSRegisterAllocation();
		
	
}

/**
 * f0 -> NoOpStmt()
 *       | ErrorStmt()
 *       | CJumpStmt()
 *       | JumpStmt()
 *       | HStoreStmt()
 *       | HLoadStmt()
 *       | MoveStmt()
 *       | PrintStmt()
 */
public void visit(Stmt n) {
	n.f0.accept(this);
}

/**
 * f0 -> "NOOP"
 */
public void visit(NoOpStmt n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	line++;
}

/**
 * f0 -> "ERROR"
 */
public void visit(ErrorStmt n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	line++;
}

/**
 * f0 -> "CJUMP"
 * f1 -> Temp()
 * f2 -> Label()
 */
public void visit(CJumpStmt n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	n.f1.accept(this);
	currentStat.use.set(identifier);					
	nextLabelList.put(currentBlock, line+1);
	jumpLabelList.put(currentBlock, n.f2.f0.toString());
	currentBlock.exit(line);
	
	line++;
	currentBlock=new MyBlock(line);
	currentProc.addBlck(currentBlock);
}

/**
 * f0 -> "JUMP"
 * f1 -> Label()
 */
public void visit(JumpStmt n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	jumpLabelList.put(currentBlock, n.f1.f0.toString());
	currentBlock.exit(line);
	
	line++;
	
}

/**
 * f0 -> "HSTORE"
 * f1 -> Temp()
 * f2 -> IntegerLiteral()
 * f3 -> Temp()
 */
public void visit(HStoreStmt n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	n.f1.accept(this);
	currentStat.use.set(identifier);
	n.f3.accept(this);
	currentStat.use.set(identifier);
	
	line++;
}

/**
 * f0 -> "HLOAD"
 * f1 -> Temp()
 * f2 -> Temp()
 * f3 -> IntegerLiteral()
 */
public void visit(HLoadStmt n) {
	n.f1.accept(this);
	currentStat.def.set(identifier);
	//lastStat=currentStat;
	//lastIdentifier=identifier;
	
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	n.f2.accept(this);
	currentStat.use.set(identifier);
	
	//if (!currentStat.use.get(lastIdentifier))
		//lastStat.def.set(lastIdentifier);
	
	line++;
}

/**
 * f0 -> "MOVE"
 * f1 -> Temp()
 * f2 -> Exp()
 */
public void visit(MoveStmt n) {
	n.f1.accept(this);
	//if (currentBlock.stats.containsKey(currentStat.line))
	//lastStat=currentStat;
	//lastIdentifier=identifier;
	currentStat.def.set(identifier);
	
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	n.f2.accept(this);
	
	//if (!currentStat.use.get(lastIdentifier))
		//lastStat.def.set(lastIdentifier);
	
	line++;
}

/**
 * f0 -> "PRINT"
 * f1 -> SimpleExp()
 */
public void visit(PrintStmt n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	
	n.f1.accept(this);
	line++;
}

/**
 * f0 -> Call()
 *       | HAllocate()
 *       | BinOp()
 *       | SimpleExp()
 */
public void visit(Exp n) {
	isLabel=true;
	n.f0.accept(this);
	isLabel=false;
}

/**
 * f0 -> "BEGIN"
 * f1 -> StmtList()
 * f2 -> "RETURN"
 * f3 -> SimpleExp()
 * f4 -> "END"
 */
public void visit(StmtExp n) {
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	line++;
	
	n.f1.accept(this);
	
	currentStat=new MyStatement(line);
	currentBlock.addStat(currentStat);
	n.f3.accept(this);
	
	line++;
	
	currentBlock.addStat(currentStat);
	currentStat=new MyStatement(line);
	
	line++;
}

/**
 * f0 -> "CALL"
 * f1 -> SimpleExp()
 * f2 -> "("
 * f3 -> ( Temp() )*
 * f4 -> ")"
 */
public void visit(Call n) {
	
	   n.f1.accept(this);
	   
	   isVars=true;
	   n.f3.accept(this);
	   isVars=false;
	   
	   //保存当前过程调用其他过程的最大参数
	   currentProc.callStats.add(line);
	   if (currentProc.maxPars<n.f3.size())
		   currentProc.maxPars=n.f3.size();
}

/**
 * f0 -> "HALLOCATE"
 * f1 -> SimpleExp()
 */
public void visit(HAllocate n) {
   n.f1.accept(this);
}

/**
 * f0 -> Operator()
 * f1 -> Temp()
 * f2 -> SimpleExp()
 */
public void visit(BinOp n) {
   n.f0.accept(this);
   n.f1.accept(this);
   currentStat.use.set(identifier);
   n.f2.accept(this);
}

/**
 * f0 -> "LT"
 *       | "PLUS"
 *       | "MINUS"
 *       | "TIMES"
 */
public void visit(Operator n) {

}

/**
 * f0 -> Temp()
 *       | IntegerLiteral()
 *       | Label()
 */
public void visit(SimpleExp n) {
   n.f0.accept(this);
   if (n.f0.which==0)	
	   currentStat.use.set(identifier);
}

/**
 * f0 -> "TEMP"
 * f1 -> IntegerLiteral()
 */
public void visit(Temp n) {
   n.f1.accept(this);
   //如果是参数，则也需要设置use位
   if (isVars)	
	   currentStat.use.set(identifier);
}

/**
 * f0 -> <INTEGER_LITERAL>
 */
public void visit(IntegerLiteral n) {
   identifier=Integer.parseInt(n.f0.toString());
}

/**
 * f0 -> <IDENTIFIER>
 */
public void visit(Label n) {
	//如果是label，则开始一个新的基本块
	if (isLabel==false) {
		nextLabelList.put(currentBlock, line);
		currentBlock.exit(line-1);
	   
		currentBlock=new MyBlock(line, n.f0.toString());
		currentProc.addBlck(currentBlock);
	}
}

}
